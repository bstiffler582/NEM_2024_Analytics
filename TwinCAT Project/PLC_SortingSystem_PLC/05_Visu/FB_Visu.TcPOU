<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Visu" Id="{80f0fe96-1376-4f3c-ab9b-90ae9e44b11c}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Visu
VAR_INPUT
	// =============== Sensors to detect boxes ==================
	bBarrierSensor			AT %I*	: BOOL;						// True if barrier sensor detects a box
	bMetalSensor			AT %I*	: BOOL;						// True if metal sensor detects a metal box
	bPlasticSensor			AT %I*	: BOOL;						// True if plastic sensor detects a box
	
	// =============== Axis =====================================
	fAxisVelo						: LREAL;					// Axis velocity
	
	// =============== State of machine elements ================
	bComprAirEnabled				: BOOL;						// True if compressed air is enabled
	bPowerEnabled					: BOOL;						// True if power supply is enabled
	bMainAxisMoves					: BOOL;						// True if main axis is moving
	bMetalAxisMoves					: BOOL;						// True if metal axis is moving
	bPlasticAxisMoves				: BOOL;						// True if plastic axis is moving
	bClampToWork					: BOOL;						// True if clamp cylinder moves to work position
	bBarrierToWork					: BOOL;						// True if barrier cylinder moves to work position
	bMetalToWork					: BOOL;						// True if metal cylinder moves to work position
	bPlasticToWork					: BOOL;						// True if plastic cylinder moves to work position
	
	// =============== Error ====================================
	bError							: BOOL;						// True if modules have errors
	bClampError						: BOOL;						// True if clamp cylinder has an error
	sClampErrMsg					: STRING;					// Error message of clamp cylinder
	bMetalCylError					: BOOL;						// True if metal cylinder has an error
	sMetalErrMsg					: STRING;					// Error message of metal cylinder
	bPlasticCylError				: BOOL;						// True if plastic cylinder has an error
	sPlasticErrMsg					: STRING;					// Error message of plastic cylinder
	nMainAxisErrorId				: UDINT;					// Error id of main axis
	nMetalAxisErrorId				: UDINT;					// Error id of metal axis
	nPlasticAxisErrorId				: UDINT;					// Error id of plastic axis
	
	// =============== PS_PackML_StateMachine ===================
	bStarted						: BOOL;						// True if state machine is in state EXECUTE
	bStopped						: BOOL;						// True if state machine is in state STOPPED
	bReset							: BOOL;						// True if state machine is in state RESETTING
	bAborted						: BOOL;						// True if state machine is in state ABORTED
	bIdle							: BOOL;						// True if state machine is in state IDLE
	bAuto							: BOOL;						// True if state machine is in mode AUTOMATIC
	bSemi							: BOOL;						// True if state machine is in mode SEMIAUTOMATIC
	bManual							: BOOL;						// True if state machine is in mode MANUAL
	bMaintenance					: BOOL;						// True if state machine is in mode MAINTENANCE
	bStartButtonOff					: BOOL;						// To turn off start button

	// =============== Buttons of visualization - inputs ========
	// State buttons
	bButtonPowerIn					: BOOL;						// Input signal of power button
	bButtonComprAirIn				: BOOL;						// Input signal of compressed air button
	bButtonStartIn					: BOOL;						// Input signal of start button
	bButtonStopIn					: BOOL;						// Input signal of stop button
	bButtonResetIn					: BOOL;						// Input signal of reset button
	bButtonAbortIn					: BOOL;						// Input signal of abort button
	
	// Mode buttons
	bButtonAutoIn					: BOOL;						// Input signal of automatic button
	bButtonSemiIn					: BOOL;						// Input signal of semi-automatic button
	bButtonManuIn					: BOOL;						// Input signal of manual button
	bButtonMaintenanceIn			: BOOL;						// Input signal of maintenance button
	
	// Axis buttons
	bButtonMainFwIn					: BOOL;						// Input signal of button to move main axis forwards
	bButtonMainBwIn					: BOOL;						// Input signal of button to move main axis backwards
	bButtonMetalFwIn				: BOOL;						// Input signal of button to move metal axis forwards
	bButtonMetalBwIn				: BOOL;						// Input signal of button to move metal axis backwards
	bButtonPlasticFwIn				: BOOL;						// Input signal of button to move plastic axis forwards
	bButtonPlasticBwIn				: BOOL;						// Input signal of button to move plastic axis backwards
	
	// Cylinder buttons
	bButtonClampToWorkIn			: BOOL;						// Input signal of button to move clamp cylinder
	bButtonBarrierToWorkIn			: BOOL;						// Input signal of button to move barrier cylinder
	bButtonMetalToWorkIn			: BOOL;						// Input signal of button to move metal cylinder
	bButtonPlasticToWorkIn			: BOOL;						// Input signal of button to move plastic cylinder
END_VAR
VAR_OUTPUT
	fYClamp					AT %Q*	: LREAL;					// Y-Coordinate of clamp cylinder
	fYBarrier				AT %Q*	: LREAL;					// Y-Coordinate of barrier cylinder
	fYMetal					AT %Q*	: LREAL;					// Y-Coordinate of metal cylinder
	fYPlastic				AT %Q*	: LREAL;					// Y-Coordinate of plastic cylinder
	aBoxX					AT %Q*	: ARRAY[1..4] OF LREAL;		// X-Coordinates of boxes
	aBoxY					AT %Q*	: ARRAY[1..4] OF LREAL;		// Y-Coordinates of boxes
	
	// =============== Buttons of visualization - outputs =======
	// State buttons
	bButtonPowerOut					: BOOL;						// To turn on and off the machine
	bButtonComprAirOut				: BOOL;						// To enable compressed air
	bButtonStartOut					: BOOL;						// To change state into state START
	bButtonStopOut					: BOOL;						// To change state into state STOP
	bButtonResetOut					: BOOL;						// To change state into state RESET
	
	// Mode buttons
	bButtonAutoOut					: BOOL;						// To change mode into mode AUTOMATIC		
	bButtonSemiOut					: BOOL;						// To change mode into mode SEMI-AUTOMATIC	
	bButtonManuOut					: BOOL;						// To change mode into mode MANAUL	
	bButtonMaintenanceOut			: BOOL;						// To change mode into mode MAINTENANCE	
	
	// Axis buttons
	bButtonMainFwOut				: BOOL;						// To move main axis forwards
	bButtonMainBwOut				: BOOL;						// To move main axis backwards
	bButtonMetalFwOut				: BOOL;						// To move metal axis forwards
	bButtonMetalBwOut				: BOOL;						// To move metal axis backwards
	bButtonPlasticFwOut				: BOOL;						// To move plastic axis forwards
	bButtonPlasticBwOut				: BOOL;						// To move plastic axis backwards
	
	// Cylinder buttons
	bButtonClampToWorkOut			: BOOL;						// To move manually clamp cylinder to work position
	bButtonBarrierToWorkOut			: BOOL;						// To move manually barrier cylinder to work position
	bButtonMetalToWorkOut			: BOOL;						// To move manually metal cylinder to work position
	bButtonPlasticToWorkOut			: BOOL;						// To move manually plastic cylinder to work position
END_VAR
VAR
	// =============== Boxes movement ===========================
	nLastBox						: INT;						// Box on last position of main belt
	aBoxMetalMove					: ARRAY[1..4] OF BOOL;		// bBoxMetalMove[1] is true, if box 1 is moved by metal cylinder
	aBoxMetalFree					: ARRAY[1..4] OF BOOL;		// bBoxMetalFree[1] is true, if any box blockades the movement of box 1 on metal belt
	aBoxPlasticMove					: ARRAY[1..4] OF BOOL;		// bBoxPlasticMove[1] is true, if box 1 is moved by plastic cylinder
	aBoxPlasticFree					: ARRAY[1..4] OF BOOL;		// bBoxMetalFree[1] is true, if any box blockades the plastic belt
	aBoxMainBelt					: ARRAY[1..4] OF BOOL;		// bBoxMainBelt[1] is true, if box 1 is on main belt and has no obstacles, so box 1 is moved by main axis
	aBoxMetalBelt					: ARRAY[1..4] OF BOOL;		// aBoxMetalBelt[1] is true, if box 1 is on metal belt and has no obstacles, so box 1 is moved by metal axis
	aBoxPlasticBelt					: ARRAY[1..4] OF BOOL;		// aBoxPlasticBelt[1] is true, if box 1 is on plastic belt and has no obstacles, so box 1 is moved by plastic axis
	fMainVelo						: LREAL;					// Velocity of boxes on main belt
	fMetalVelo						: LREAL;					// Velocity of boxes on metal belt
	fPlasticVelo					: LREAL;					// Velocity of boxes on plastic belt
	bAccident						: BOOL;						// True if machine caused an accident
	nState							: INT;
	
	// =============== Message ==================================
	nMessages						: INT;						// Number of messages
	sMessageClamp					: STRING;					// Message of clamp cylinder
	sMessageMetalCyl				: STRING;					// Message of metal cylinder
	sMessagePlasticCyl				: STRING;					// Message of plastic cylinder
	sMessageMainAxis				: STRING;					// Message of main axis
	sMessageMetalAxis				: STRING;					// Message of metal axis
	sMessagePlasticAxis				: STRING;					// Message of plastic axis
	
	// =============== Axes movement ============================
	nAngleMain						: INT;						// Angle of main axis element
	nAngleMetal						: INT;						// Angle of metal axis element
	nAnglePlastic					: INT;						// Angle of plastic axis element
	fbTimerMainAxis					: TON;						// Timer for movement of main axis element
	fbTimerMetalAxis				: TON;						// Timer for movement of metal axis element
	fbTimerPlasticAxis				: TON;						// Timer for movement of plastic axis element
	tMoveAxis						: TIME := T#40MS;			// Time for movement of elements

	// =============== Color variables ==========================
	nButtonColorStart				: DWORD;					// Color of start button
	bButtonColorStart				: BOOL;						// To change color of start button
	nButtonColorStop				: DWORD;					// Color of stop button
	bButtonColorStop				: BOOL;						// To change color of stop button
	nButtonColorReset				: DWORD;					// Color of reset button
	bButtonColorReset				: BOOL;						// To change color of reset button
	nButtonColorAuto				: DWORD;					// Color of automatic button
	bButtonColorAuto				: BOOL;						// To change color of automatic button
	nButtonColorSemi				: DWORD;					// Color of semi-automatic button
	bButtonColorSemi				: BOOL;						// To change color of semi-automatic button
	nButtonColorManu				: DWORD;					// Color of manual button
	bButtonColorManu				: BOOL;						// To change color of manual button
	nButtonColorMaint				: DWORD;					// Color of maintenance button
	bButtonColorMaint				: BOOL;						// To change color of maintenance button
	nButtonColorClamp				: DWORD;					// Color of button to move clamp cylinder
	bButtonColorClamp				: BOOL;						// To change color of clamp button
	nButtonColorBarrier				: DWORD;					// Color of button to move barrier cylinder
	bButtonColorBarrier				: BOOL;						// To change color of barrier button
	nButtonColorMetalCyl			: DWORD;					// Color of button to move metal cylinder
	bButtonColorMetalCyl			: BOOL;						// To change color of metal cylinder button
	nButtonColorPlasticCyl			: DWORD;					// Color of button to move plastic cylinder
	bButtonColorPlasticCyl			: BOOL;						// To change color of plastic cylinder button
	nButtonColorMainFw				: DWORD;					// Color of button to move main axis forwards
	bButtonColorMainFw				: BOOL;						// To change color of button to move main axis fw.
	nButtonColorMainBw				: DWORD;					// Color of button to move main axis backwards
	bButtonColorMainBw				: BOOL;						// To change color of button to move main axis bw.
	nButtonColorMetalFw				: DWORD;					// Color of button to move metal axis forwards
	bButtonColorMetalFw				: BOOL;						// To change color of button to move metal axis fw.
	nButtonColorMetalBw				: DWORD;					// Color of button to move metal axis backwards
	bButtonColorMetalBw				: BOOL;						// To change color of button to move metal axis bw.
	nButtonColorPlasticFw			: DWORD;					// Color of button to move plastic axis forwards
	bButtonColorPlasticFw			: BOOL;						// To change color of button to move plastic axis fw.
	nButtonColorPlasticBw			: DWORD;					// Color of button to move plastic axis backwards
	bButtonColorPlasticBw			: BOOL;						// To change color of button to move plastic axis bw.
	nButtonColorComprAir			: DWORD;					// Color of button to enable/disable compressed air
	bButtonColorComprAir			: BOOL;						// To change color of button to control compressed air
	
	// ================= PPM calc ===========================================
	ctTotalCtr						: CTU;
	ctMetalCtr						: CTU;
	arrTotal						: ARRAY[0..9] OF DINT;
	arrMetal						: ARRAY[0..9] OF DINT;
	tmrPpm							: TON;
	
END_VAR
VAR CONSTANT
	// =============== Colors ===============================================
	cYellow 									: DWORD	:= 16#00FFFF80;		// Color code for yellow
	cGreen 										: DWORD	:= 16#0080FF00;		// Color code for green
	cPink 										: DWORD	:= 16#00FF8080;		// Color code for pink
	
	// =============== Velocities ===========================================
	cVelocityDenominator						: LREAL := 250.0;			// Velocity of visualization is a fraction of real axis velocity
	cAxisMovementSemiPlusAuto					: INT 	:= 2;				// Axis movement per cycle in mode Automatic and Semi Autoamtic
	cAxisMovementManual							: INT 	:= 1;				// Axis movement per cycle in mode Manual
	cClampMovement								: LREAL := 0.1;				// Cylinder movement per cycle for clamp cylinder
	cBarrierMovement							: LREAL := 1.0;				// Cylinder movement per cycle for barrier cylinder
	cMetalPlasticCylMovement					: LREAL := 1.0;				// Cylinder movement per cycle for metal and plastic cylinder
	
	// =============== Barrier, clamp, metal, plastic cylinder ==============
	cYClampCylStartPos							: LREAL := 0.0;				// Y-start-position of clamp cylinder (where movement starts)
	cYClampCylEndPos							: LREAL := 3.0;				// Y-end-position of clamp cylinder (where movement ends)
	cYBarrierCylStartPos						: LREAL := 0.0;				// Y-start-position of barrier cylinder (where movement starts)
	cYBarrierCylEndPos							: LREAL := 63.0;			// Y-end-position of barrier cylinder (where movement ends)
	cYMetalPlasticCylStartPos					: LREAL := 0.0;				// Y-start-position of metal and plastic cylinder (where movement starts)
	cYMetalPlasticCylEndPos						: LREAL := -73.0;			// Y-end-position of metal and plastic cylinder (where movement ends)
	
	// =============== Widths, distances ====================================
	cBoxWidth									: LREAL := 60.0;			// Width of a box in the visu
	cBarrierWidth								: LREAL := 30.0;			// Width of the barrier cylinder in the visu
	cDiffBarrierToStartOfMetalCyl				: LREAL := 191.0;			// Difference on visu from barrier to start of metal cylinder
	cDiffBarrierToEndOfMetalCyl					: LREAL := 261.0;			// Difference on visu from barrier to end of metal cylinder
	cDiffBarrierToStartOfPlasticCyl				: LREAL := 441.0;			// Difference on visu from barrier to start of plastic cylinder
	cYMetalPlasticCylOnMainBelt					: LREAL := -9.0;			// Y-Position of metal and plastic cylinder reaching the main belt
	cYBoxesOnMetalPlasticBelt_min				: LREAL := -65.0;			// Minimal Y-Position of boxes when being on metal or plastic belt
	cYBoxesOnMetalPlasticBelt_max				: LREAL := -140.0;			// Maximal Y-Position of boxes when being on metal or plastic belt
	
	// =============== Positions of boxes - main belt =======================
	cYforAllBoxesOnMainBelt						: LREAL := -5.0;			// Y-Position of boxes being on main belt
	cYforAllBoxesNotOnMainBelt					: LREAL := -60.0;			// Y-Position of boxes not being on main belt
	
	cYforAllBoxesStartPosMainBelt				: LREAL := 0.0;				// Y-Position of boxes when being on first position of main belt
	cXforAllBoxesStartPosMainBelt				: LREAL := -240.0;			// X-Position of boxes when being on first position of main belt
	cXforAllBoxesLastPossiblePosMainBelt		: LREAL := 461.0;			// Last possible X-position of boxes on main belt
	
	cXforAllBoxesCorrectPushMetalCyl_min		: LREAL := 180;				// Minimal X-Position of boxes when being pushed by metal cylinder to metal belt 
	cXforAllBoxesCorrectPushMetalCyl_max		: LREAL := 211;				// Maximal X-Position of boxes when being pushed by metal cylinder to metal belt 
	cXforAllBoxesIncorrectPushMetalCyl_min		: LREAL := 131;				// Minimal X-Position of boxes when being pushed by metal cylinder, but not pushed to metal belt
	cXforAllBoxesIncorrectPushMetalCyl_max		: LREAL := 261;				// Maximal X-Position of boxes when being pushed by metal cylinder, but not pushed to metal belt
	
	cXforAllBoxesCorrectPushPlasticCyl_min		: LREAL := 430;				// Minimal X-Position of boxes when being pushed by plastic cylinder to plastic belt 
	cXforAllBoxesCorrectPushPlasticCyl_max		: LREAL := 461;				// Minimal X-Position of boxes when being pushed by plastic cylinder to plastic belt 
	cXforAllBoxesIncorrectPushPlasticCyl_min	: LREAL := 381;				// Minimal X-Position of boxes when being pushed by plastic cylinder, but not pushed to plastic belt
	
	// Box 1
	cXforBox1_MainBelt_Diff2to1_min				: LREAL := 0.001;			// Minimal distance from box 2 to box 1 so that box 1 can be moved on main belt
	cXforBox1_MainBelt_Diff2to1_max				: LREAL := 119.99999;		// Maximal distance from box 2 to box 1 so that box 1 can be moved on main belt
	cXforBox1_MainBelt_Diff3to1_min				: LREAL := 60.001;			// Minimal distance from box 3 to box 1 so that box 1 can be moved on main belt
	cXforBox1_MainBelt_Diff3to1_max				: LREAL := 179.99999;		// Maximal distance from box 3 to box 1 so that box 1 can be moved on main belt
	cXforBox1_MainBelt_Diff4to1_min				: LREAL := 120.001;			// Minimal distance from box 4 to box 1 so that box 1 can be moved on main belt
	cXforBox1_MainBelt_Diff4to1_max				: LREAL := 239.99999;		// Maximal distance from box 4 to box 1 so that box 1 can be moved on main belt
	
	// Box 2
	cXforBox2_MainBelt_Diff1to2_min				: LREAL := -0.00001;		// Minimal distance from box 1 to box 2 so that box 2 can be moved on main belt
	cXforBox2_MainBelt_Diff1to2_max				: LREAL := -119.999;		// Maximal distance from box 1 to box 2 so that box 2 can be moved on main belt
	cXforBox2_MainBelt_Diff3to2_min				: LREAL := 119.99999;		// Minimal distance from box 3 to box 2 so that box 2 can be moved on main belt
	cXforBox2_MainBelt_Diff3to2_max				: LREAL := 0.001;			// Maximal distance from box 3 to box 2 so that box 2 can be moved on main belt
	cXforBox2_MainBelt_Diff4to2_min				: LREAL := 179.99999;		// Minimal distance from box 4 to box 2 so that box 2 can be moved on main belt
	cXforBox2_MainBelt_Diff4to2_max				: LREAL := 60.001;			// Maximal distance from box 4 to box 2 so that box 2 can be moved on main belt

	// Box 3
	cXforBox3_MainBelt_Diff1to3_min				: LREAL := -60.00001;		// Minimal distance from box 1 to box 3 so that box 3 can be moved on main belt
	cXforBox3_MainBelt_Diff1to3_max				: LREAL := -179.999;		// Maximal distance from box 1 to box 3 so that box 3 can be moved on main belt
	cXforBox3_MainBelt_Diff2to3_min				: LREAL := -0.00001;		// Minimal distance from box 2 to box 3 so that box 3 can be moved on main belt
	cXforBox3_MainBelt_Diff2to3_max				: LREAL := -119.999;		// Maximal distance from box 2 to box 3 so that box 3 can be moved on main belt
	cXforBox3_MainBelt_Diff4to3_min				: LREAL := 119.99999;		// Minimal distance from box 4 to box 3 so that box 3 can be moved on main belt
	cXforBox3_MainBelt_Diff4to3_max				: LREAL := 0.001;			// Maximal distance from box 4 to box 3 so that box 3 can be moved on main belt
	
	// Box 4
	cXforBox4_MainBelt_Diff1to4_min				: LREAL := -120.00001;		// Minimal distance from box 1 to box 4 so that box 4 can be moved on main belt
	cXforBox4_MainBelt_Diff1to4_max				: LREAL := -239.999;		// Maximal distance from box 1 to box 4 so that box 4 can be moved on main belt
	cXforBox4_MainBelt_Diff2to4_min				: LREAL := -60.00001;		// Minimal distance from box 2 to box 4 so that box 4 can be moved on main belt
	cXforBox4_MainBelt_Diff2to4_max				: LREAL := -179.999;		// Maximal distance from box 2 to box 4 so that box 4 can be moved on main belt
	cXforBox4_MainBelt_Diff3to4_min				: LREAL := -0.00001;		// Minimal distance from box 3 to box 4 so that box 4 can be moved on main belt
	cXforBox4_MainBelt_Diff3to4_max				: LREAL := -119.999;		// Maximal distance from box 3 to box 4 so that box 4 can be moved on main belt
	
	// =============== Positions of boxes - metal belt ======================
	// Box 1
	cXforBox1OnMetalBelt_min					: LREAL := 240;				// Minimal X-Position of box 1 when being on metal belt
	cXforBox1OnMetalBelt_max					: LREAL := 271;				// Maximal X-Position of box 1 when being on metal belt
	// Box 2
	cXforBox2OnMetalBelt_min					: LREAL := 300;				// Minimal X-Position of box 2 when being on metal belt
	cXforBox2OnMetalBelt_max					: LREAL := 331;				// Maximal X-Position of box 2 when being on metal belt
	// Box 3
	cXforBox3OnMetalBelt_min					: LREAL := 360;				// Minimal X-Position of box 3 when being on metal belt
	cXforBox3OnMetalBelt_max					: LREAL := 391;				// Maximal X-Position of box 3 when being on metal belt
	// Box 4
	cXforBox4OnMetalBelt_min					: LREAL := 420;				// Minimal X-Position of box 4 when being on metal belt
	cXforBox4OnMetalBelt_max					: LREAL := 451;				// Maximal X-Position of box 4 when being on metal belt
	
	// =============== Positions of boxes - plastic belt ====================
	// Box 1
	cXforBox1OnPlasticBelt_min					: LREAL := 470;				// Minimal X-Position of box 1 when being on plastic belt
	cXforBox1OnPlasticBelt_max					: LREAL := 521;				// Maximal X-Position of box 1 when being on plastic belt
	// Box 2
	cXforBox2OnPlasticBelt_min					: LREAL := 530;				// Minimal X-Position of box 2 when being on plastic belt
	cXforBox2OnPlasticBelt_max					: LREAL := 581;				// Maximal X-Position of box 2 when being on plastic belt
	// Box 3
	cXforBox3OnPlasticBelt_min					: LREAL := 590;				// Minimal X-Position of box 3 when being on plastic belt
	cXforBox3OnPlasticBelt_max					: LREAL := 641;				// Maximal X-Position of box 3 when being on plastic belt
	// Box 4
	cXforBox4OnPlasticBelt_min					: LREAL := 650;				// Minimal X-Position of box 4 when being on plastic belt
	cXforBox4OnPlasticBelt_max					: LREAL := 701;				// Maximal X-Position of box 4 when being on plastic belt
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// =========================================================
// Resetting visu
	
	IF bReset THEN
		Reset();
	END_IF

// =========================================================
// Because of the visualisation size, the boxes velocity is a fraction of the axis velocity
	
	IF bAuto OR bSemi OR bButtonMainFwIn THEN
		fMainVelo := (fAxisVelo / cVelocityDenominator);
	ELSIF bButtonMainBwIn THEN
		fMainVelo := -(fAxisVelo / cVelocityDenominator);
	END_IF
	
	IF bAuto OR bSemi OR bButtonMetalFwIn THEN
		fMetalVelo := -(fAxisVelo / cVelocityDenominator);
	ELSIF bButtonMetalBwIn THEN
		fMetalVelo := (fAxisVelo / cVelocityDenominator);
	END_IF
	
	IF bAuto OR bSemi OR bButtonPlasticFwIn THEN
		fPlasticVelo := -(fAxisVelo / cVelocityDenominator);
	ELSIF bButtonPlasticBwIn THEN
		fPlasticVelo := (fAxisVelo / cVelocityDenominator);
	END_IF

// =========================================================
// In case of accident the power button is turned off
	
	IF bAccident THEN
		IF bButtonPowerOut THEN
			bButtonPowerOut := FALSE;
		END_IF
		
		IF bStopped THEN
			bAccident := FALSE;
		END_IF
	END_IF

// =========================================================
// Visuazation functions

	// Rotation of axis elements
	AxisRotation();
	
	// Buttons, order of boxes, error messages
	ButtonSignals();
	ButtonColors();
	LastBox();
	ErrorMessages();
	
	// Motion of cylinders
	Barrier_Clamp_Cyl();
	Metal_Plastic_Cyl();
	
	// Motion of boxes
	AxisMoveBoxes();
	CylinderMoveBoxes();

// =========================================================

// ==========================================================
// part per min calculation
tmrPpm(IN:=(NOT tmrPpm.Q), PT:=T#60S);
IF tmrPpm.Q THEN
	MEMCPY(ADR(arrTotal[1]), ADR(arrTotal[0]), SIZEOF(DINT) * 9);
	MEMCPY(ADR(arrMetal[1]), ADR(arrMetal[0]), SIZEOF(DINT) * 9);
END_IF
ctTotalCtr(CU:=bMetalToWork OR bPlasticToWork, CV=>arrTotal[0], RESET:=tmrPpm.Q);
ctMetalCtr(CU:=bMetalToWork, CV=>arrMetal[0], RESET:=tmrPpm.Q);

// ===========================================================]]></ST>
    </Implementation>
    <Method Name="AxisMoveBoxes" Id="{db80a2a9-d7dd-48b7-8ded-9020c68b7fe6}">
      <Declaration><![CDATA[METHOD PRIVATE AxisMoveBoxes
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Checking traction standby on main belt
// bBoxMainBelt[1] is true, if box 1 is on main belt and has no obstacles, so box 1 is moved by main axis
		
	aBoxMainBelt[1] := 	// box 1 on main belt
						aBoxY[1] >= cYforAllBoxesOnMainBelt	
						// not previous to box 2											
						AND (	(aBoxX[2] - aBoxX[1] - fMainVelo) >= cXforBox1_MainBelt_Diff2to1_max
							OR 	(aBoxX[2] - aBoxX[1] - fMainVelo) <= cXforBox1_MainBelt_Diff2to1_min
							OR 	aBoxY[2] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 3	
						AND (	(aBoxX[3] - aBoxX[1] - fMainVelo) >= cXforBox1_MainBelt_Diff3to1_max
							OR 	(aBoxX[3] - aBoxX[1]- fMainVelo) <= cXforBox1_MainBelt_Diff3to1_min
							OR 	aBoxY[3] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 4
						AND (	(aBoxX[4] - aBoxX[1] - fMainVelo) >= cXforBox1_MainBelt_Diff4to1_max
							OR 	(aBoxX[4] - aBoxX[1]- fMainVelo) <= cXforBox1_MainBelt_Diff4to1_min
							OR	aBoxY[4] < cYforAllBoxesNotOnMainBelt);
						
	aBoxMainBelt[2] := 	// box 2 on main belt
						aBoxY[2] >= cYforAllBoxesOnMainBelt
						// not previous to box 1											
						AND (	(aBoxX[1] - aBoxX[2] - fMainVelo) >= cXforBox2_MainBelt_Diff1to2_min 
							OR 	(aBoxX[1] - aBoxX[2] - fMainVelo) <= cXforBox2_MainBelt_Diff1to2_max 
							OR 	aBoxY[1] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 3											
						AND (	(aBoxX[3] - aBoxX[2] - fMainVelo) >= cXforBox2_MainBelt_Diff3to2_min 
							OR 	(aBoxX[3] - aBoxX[2] - fMainVelo) <= cXforBox2_MainBelt_Diff3to2_max 
							OR 	aBoxY[3] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 4											
						AND (	(aBoxX[4] - aBoxX[2] - fMainVelo) >= cXforBox2_MainBelt_Diff4to2_min 
							OR 	(aBoxX[4] - aBoxX[2] - fMainVelo) <= cXforBox2_MainBelt_Diff4to2_max 
							OR 	aBoxY[4] < cYforAllBoxesNotOnMainBelt);
	
	aBoxMainBelt[3] := 	// box 3 on main belt
						aBoxY[3] >= cYforAllBoxesOnMainBelt
						// not previous to box 1											
						AND (	(aBoxX[1] - aBoxX[3] - fMainVelo) >= cXforBox3_MainBelt_Diff1to3_min
							OR 	(aBoxX[1] - aBoxX[3] - fMainVelo) <= cXforBox3_MainBelt_Diff1to3_max
							OR 	aBoxY[1] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 2											
						AND (	(aBoxX[2] - aBoxX[3] - fMainVelo) >= cXforBox3_MainBelt_Diff2to3_min
							OR 	(aBoxX[2] - aBoxX[3] - fMainVelo) <= cXforBox3_MainBelt_Diff2to3_max 
							OR 	aBoxY[2] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 4											
						AND (	(aBoxX[4] - aBoxX[3] - fMainVelo) >= cXforBox3_MainBelt_Diff4to3_min
							OR 	(aBoxX[4] - aBoxX[3] - fMainVelo) <= cXforBox3_MainBelt_Diff4to3_max
							OR 	aBoxY[4] < cYforAllBoxesNotOnMainBelt);
						
	aBoxMainBelt[4] := 	// box 4 on main belt
						aBoxY[4] >= cYforAllBoxesOnMainBelt
						// not previous to box 1											
						AND (	(aBoxX[1] - aBoxX[4] - fMainVelo) >= cXforBox4_MainBelt_Diff1to4_min
							OR 	(aBoxX[1] - aBoxX[4] - fMainVelo) <= cXforBox4_MainBelt_Diff1to4_max
							OR 	aBoxY[1] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 2											
						AND (	(aBoxX[2] - aBoxX[4] - fMainVelo) >= cXforBox4_MainBelt_Diff2to4_min
							OR 	(aBoxX[2] - aBoxX[4] - fMainVelo) <= cXforBox4_MainBelt_Diff2to4_max
							OR 	aBoxY[2] < cYforAllBoxesNotOnMainBelt)
						// not previous to box 3											
						AND (	(aBoxX[3] - aBoxX[4] - fMainVelo) >= cXforBox4_MainBelt_Diff3to4_min
							OR 	(aBoxX[3] - aBoxX[4] - fMainVelo) <= cXforBox4_MainBelt_Diff3to4_max
							OR 	aBoxY[3] < cYforAllBoxesNotOnMainBelt);
					
// =========================================================
// Motion of boxes on main belt - forwards
					
	IF bMainAxisMoves AND (bAuto OR bSemi OR bButtonMainFwIn) THEN
		FOR nState := 1 TO 4 BY 1 DO
			IF aBoxMainBelt[nState] THEN	
				// not previous to moving metal cylinder
				IF aBoxX[nState] >= (cBoxWidth*nState + cBarrierWidth) AND aBoxX[nState] < (cBoxWidth*nState + cDiffBarrierToEndOfMetalCyl - 1) THEN
					// Metal cylinder over main belt
					IF fYMetal <= cYMetalPlasticCylOnMainBelt THEN
						IF aBoxX[nState] < (cBoxWidth*nState + cDiffBarrierToStartOfMetalCyl - cBoxWidth + 0.25)
						AND aBoxX[nState] > (cBoxWidth*nState + cDiffBarrierToStartOfMetalCyl - cBoxWidth - 0.15) THEN
							aBoxX[nState] := cBoxWidth*nState + cDiffBarrierToStartOfMetalCyl - cBoxWidth;
						ELSIF aBoxX[nState] <= (cBoxWidth*nState + cDiffBarrierToStartOfMetalCyl - cBoxWidth - 0.15) THEN
							aBoxX[nState] := aBoxX[nState] + fMainVelo;
						END_IF
					// Metal cylinder not over main belt
					ELSE
						aBoxX[nState] := aBoxX[nState] + fMainVelo;
					END_IF
				END_IF
				
				// not previous to moving plastic cylinder
				IF aBoxX[nState] >= (cBoxWidth*nState + cDiffBarrierToEndOfMetalCyl - 1) THEN
					// Plastic cylinder over main belt
					IF fYPlastic <= cYMetalPlasticCylOnMainBelt THEN
						IF aBoxX[nState] < (cBoxWidth*nState + cDiffBarrierToStartOfPlasticCyl - cBoxWidth + 0.25)
						AND aBoxX[nState] > (cBoxWidth*nState + cDiffBarrierToStartOfPlasticCyl - cBoxWidth - 0.15) THEN
							aBoxX[nState] := cBoxWidth*nState + cDiffBarrierToStartOfPlasticCyl - cBoxWidth;
						ELSIF aBoxX[nState] <= (cBoxWidth*nState + cDiffBarrierToStartOfPlasticCyl - cBoxWidth - 0.15) THEN
							aBoxX[nState] := aBoxX[nState] + fMainVelo;
						END_IF
					// Plastic cylinder not over main belt
					ELSE
						aBoxX[nState] := aBoxX[nState] + fMainVelo;
					END_IF
				END_IF
				
				// barrier open and box 1 in the first place
				IF fYBarrier >= (cBoxWidth + 1) AND aBoxX[nState] >= cBoxWidth*(nState - 1) AND aBoxX[nState] <  (cBoxWidth*nState + cBarrierWidth) THEN
					IF aBoxX[nState] + fMainVelo < (cBoxWidth*nState + cBarrierWidth) THEN
						 aBoxX[nState] := aBoxX[nState] + fMainVelo;
					ELSIF aBoxX[nState] < (cBoxWidth*nState + cBarrierWidth) THEN
						aBoxX[nState] := (cBoxWidth*nState + cBarrierWidth);
					END_IF
				END_IF
				
				// not previous to clamp
				IF aBoxX[nState] + fMainVelo < -cBoxWidth*(3 - nState) THEN
					aBoxX[nState] := aBoxX[nState] + fMainVelo;
				ELSIF aBoxX[nState] < -cBoxWidth*(nState + 1) THEN
					aBoxX[nState] := -cBoxWidth*(nState + 1);
				END_IF
				
				// clamp open, not after clamp											
				IF fYClamp >= 1 AND aBoxX[nState] >= -cBoxWidth*(nState + 1) THEN
					IF aBoxX[nState] + fMainVelo < cBoxWidth*(nState - 1) THEN
						aBoxX[nState] := aBoxX[nState] + fMainVelo;
					ELSIF aBoxX[nState] < cBoxWidth*(nState - 1) THEN
						aBoxX[nState] := cBoxWidth*(nState - 1);
					END_IF
				END_IF
			END_IF
		END_FOR
	END_IF

// =========================================================
// Motion of boxes on main belt - backwards
	
	IF bMainAxisMoves AND bButtonMainBwIn THEN 
		FOR nState := 1 TO 4 BY 1 DO
			IF aBoxMainBelt[nState] THEN
				// not previous to moving metal cylinder
				IF aBoxX[nState] >= (cBoxWidth*nState + cBoxWidth + cBarrierWidth) AND aBoxX[nState] < (cBoxWidth*nState + cDiffBarrierToEndOfMetalCyl + 1) THEN
					IF NOT (aBoxX[nState] < (cBoxWidth*nState + cDiffBarrierToEndOfMetalCyl + 0.25)
					AND aBoxX[nState] > (cBoxWidth*nState + cDiffBarrierToEndOfMetalCyl - 0.15)
					AND fYMetal <= cYMetalPlasticCylOnMainBelt) THEN
						aBoxX[nState] := aBoxX[nState] + fMainVelo;
					ELSE
						aBoxX[nState] := cBoxWidth*nState + cDiffBarrierToEndOfMetalCyl;
					END_IF
				END_IF
				
				// not previous to moving plastic cylinder
				IF aBoxX[nState] >= (cBoxWidth*nState + cDiffBarrierToEndOfMetalCyl + 1) THEN
					aBoxX[nState] := aBoxX[nState] + fMainVelo;
				END_IF
				
				// not previous to moving barrier cylinder
				IF aBoxX[nState] > cBoxWidth*(nState - 1) AND aBoxX[nState] < (cBoxWidth*nState + cBoxWidth + cBarrierWidth) THEN
					IF NOT (aBoxX[nState] < (cBoxWidth*nState + cBarrierWidth + 0.25)
					AND aBoxX[nState] > (cBoxWidth*nState + cBarrierWidth - 0.15)
					AND fYBarrier < (cBoxWidth + 1)) THEN
						aBoxX[nState] := aBoxX[nState] + fMainVelo;
					ELSE
						aBoxX[nState] := cBoxWidth*nState + cBarrierWidth;
					END_IF
				END_IF
				
				// barrier open and box 1 after the first place
				IF fYBarrier >= (cBoxWidth + 1) AND aBoxX[nState] < cBoxWidth*(nState + 1) AND aBoxX[nState] > cBoxWidth*(nState - 1) THEN
					aBoxX[nState] := aBoxX[nState] + fMainVelo;
				END_IF	
				
				// clamp open, not previous to clamp											
				IF fYClamp >= 1 AND aBoxX[nState] <= cBoxWidth*(nState-1) AND aBoxX[nState] > -cBoxWidth*(3-nState) THEN
					aBoxX[nState] := aBoxX[nState] + fMainVelo;
				END_IF
				
				// not at the beginning of main belt
				IF aBoxX[nState] > -cBoxWidth*(4-nState) AND aBoxX[nState] <= -cBoxWidth*(3-nState) THEN
					aBoxX[nState] := aBoxX[nState] + fMainVelo;
				END_IF
			END_IF
		END_FOR	
	END_IF

// =========================================================
// =========================================================
// Checking traction standby on metal belt
	
	aBoxMetalBelt[1] := // box 1 on metal belt
						aBoxX[1] > cXforBox1OnMetalBelt_min AND aBoxX[1] <= cXforBox1OnMetalBelt_max
						// not previous to box 2											
						AND ((aBoxY[2] - aBoxY[1] - fMetalVelo) >= cBoxWidth OR (aBoxY[2] - aBoxY[1] - fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[2] > cXforBox2OnMetalBelt_min AND aBoxX[2] <= cXforBox2OnMetalBelt_max))
						// not previous to box 3	
						AND ((aBoxY[3] - aBoxY[1]- fMetalVelo) >= cBoxWidth OR (aBoxY[3] - aBoxY[1]- fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[3] > cXforBox3OnMetalBelt_min AND aBoxX[3] <= cXforBox3OnMetalBelt_max))
						// not previous to box 4
						AND ((aBoxY[4] - aBoxY[1]- fMetalVelo) >= cBoxWidth OR (aBoxY[4] - aBoxY[1]- fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[4] > cXforBox4OnMetalBelt_min AND aBoxX[4] <= cXforBox4OnMetalBelt_max));	
						
	aBoxMetalBelt[2] := aBoxX[2] > cXforBox2OnMetalBelt_min AND aBoxX[2] <= cXforBox2OnMetalBelt_max										
						AND ((aBoxY[1] - aBoxY[2] - fMetalVelo) >= cBoxWidth OR (aBoxY[1] - aBoxY[2] - fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[1] > cXforBox1OnMetalBelt_min AND aBoxX[1] <= cXforBox1OnMetalBelt_max))
						AND ((aBoxY[3] - aBoxY[2]- fMetalVelo) >= cBoxWidth OR (aBoxY[3] - aBoxY[2]- fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[3] > cXforBox3OnMetalBelt_min AND aBoxX[3] <= cXforBox3OnMetalBelt_max))
						AND ((aBoxY[4] - aBoxY[2]- fMetalVelo) >= cBoxWidth OR (aBoxY[4] - aBoxY[2]- fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[4] > cXforBox4OnMetalBelt_min AND aBoxX[4] <= cXforBox4OnMetalBelt_max));	
						
	aBoxMetalBelt[3] := aBoxX[3] > cXforBox3OnMetalBelt_min AND aBoxX[3] <= cXforBox3OnMetalBelt_max										
						AND ((aBoxY[1] - aBoxY[3] - fMetalVelo) >= cBoxWidth OR (aBoxY[1] - aBoxY[3] - fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[1] > cXforBox1OnMetalBelt_min AND aBoxX[1] <= cXforBox1OnMetalBelt_max))
						AND ((aBoxY[2] - aBoxY[3]- fMetalVelo) >= cBoxWidth OR (aBoxY[2] - aBoxY[3]- fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[2] > cXforBox2OnMetalBelt_min AND aBoxX[2] <= cXforBox2OnMetalBelt_max))
						AND ((aBoxY[4] - aBoxY[3]- fMetalVelo) >= cBoxWidth OR (aBoxY[4] - aBoxY[3]- fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[4] > cXforBox4OnMetalBelt_min AND aBoxX[4] <= cXforBox4OnMetalBelt_max));	
						
	aBoxMetalBelt[4] := aBoxX[4] > cXforBox4OnMetalBelt_min AND aBoxX[4] <= cXforBox4OnMetalBelt_max										
						AND ((aBoxY[1] - aBoxY[4] - fMetalVelo) >= cBoxWidth OR (aBoxY[1] - aBoxY[4] - fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[1] > cXforBox1OnMetalBelt_min AND aBoxX[1] <= cXforBox1OnMetalBelt_max))
						AND ((aBoxY[2] - aBoxY[4] - fMetalVelo) >= cBoxWidth OR (aBoxY[2] - aBoxY[4] - fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[2] > cXforBox2OnMetalBelt_min AND aBoxX[2] <= cXforBox2OnMetalBelt_max))
						AND ((aBoxY[3] - aBoxY[4]- fMetalVelo) >= cBoxWidth OR (aBoxY[3] - aBoxY[4]- fMetalVelo) <= -cBoxWidth
							OR NOT (aBoxX[3] > cXforBox3OnMetalBelt_min AND aBoxX[3] <= cXforBox3OnMetalBelt_max));

// =========================================================
// Motion of boxes on metal belt and back to the start position number 4
	
	FOR nState := 1 TO 4 BY 1 DO	
		IF bMetalAxisMoves THEN
			IF 	aBoxMetalBelt[nState] THEN
					// Check the state and direction of motion		
					IF bAuto OR bSemi OR (NOT bAuto AND bButtonMetalFwIn) THEN
						// Move box to the end of metal belt and then back to position 4	
						IF aBoxY[nState] <= (cYBoxesOnMetalPlasticBelt_min + 0.1) AND aBoxY[nState] > cYBoxesOnMetalPlasticBelt_max THEN
							aBoxY[nState] := aBoxY[nState] + fMetalVelo;
						END_IF
						
					ELSIF NOT bAuto AND bButtonMetalBwIn THEN
						IF aBoxY[nState] + fMetalVelo <= (cYBoxesOnMetalPlasticBelt_min - 0.1) THEN
							aBoxY[nState] := aBoxY[nState] + fMetalVelo;
						END_IF
					END_IF
			END_IF
		END_IF	
		
		IF aBoxY[nState] <= cYBoxesOnMetalPlasticBelt_max AND nLastBox = 0 THEN
			aBoxY[nState] := cYforAllBoxesStartPosMainBelt;
			aBoxX[nState] := cXforAllBoxesStartPosMainBelt + nState*cBoxWidth;
		END_IF
	END_FOR
	
// =========================================================
// =========================================================
// Checking traction standby on plastic belt
	
	aBoxPlasticBelt[1] := // box 1 on plastic belt
						aBoxX[1] > cXforBox1OnPlasticBelt_min AND aBoxX[1] <= cXforBox1OnPlasticBelt_max	
						// not previous to box 2											
						AND ((aBoxY[2] - aBoxY[1] - fPlasticVelo) >= cBoxWidth OR (aBoxY[2] - aBoxY[1] - fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[2] > cXforBox2OnPlasticBelt_min AND aBoxX[2] <= cXforBox2OnPlasticBelt_max))
						// not previous to box 3	
						AND ((aBoxY[3] - aBoxY[1]- fPlasticVelo) >= cBoxWidth OR (aBoxY[3] - aBoxY[1]- fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[3] > cXforBox3OnPlasticBelt_min AND aBoxX[3] <= cXforBox3OnPlasticBelt_max))
						// not previous to box 4
						AND ((aBoxY[4] - aBoxY[1]- fPlasticVelo) >= cBoxWidth OR (aBoxY[4] - aBoxY[1]- fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[4] > cXforBox4OnPlasticBelt_min AND aBoxX[4] <= cXforBox4OnPlasticBelt_max));	
						
	aBoxPlasticBelt[2] := aBoxX[2] > cXforBox2OnPlasticBelt_min AND aBoxX[2] <= cXforBox2OnPlasticBelt_max									
						AND ((aBoxY[1] - aBoxY[2] - fPlasticVelo) >= cBoxWidth OR (aBoxY[1] - aBoxY[2] - fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[1] > cXforBox1OnPlasticBelt_min AND aBoxX[1] <= cXforBox1OnPlasticBelt_max))
						AND ((aBoxY[3] - aBoxY[2]- fPlasticVelo) >= cBoxWidth OR (aBoxY[3] - aBoxY[2]- fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[3] > cXforBox3OnPlasticBelt_min AND aBoxX[3] <= cXforBox3OnPlasticBelt_max))
						AND ((aBoxY[4] - aBoxY[2]- fPlasticVelo) >= cBoxWidth OR (aBoxY[4] - aBoxY[2]- fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[4] > cXforBox4OnPlasticBelt_min AND aBoxX[4] <= cXforBox4OnPlasticBelt_max));	
						
	aBoxPlasticBelt[3] := aBoxX[3] > cXforBox3OnPlasticBelt_min AND aBoxX[3] <= cXforBox3OnPlasticBelt_max										
						AND ((aBoxY[1] - aBoxY[3] - fPlasticVelo) >= cBoxWidth OR (aBoxY[1] - aBoxY[3] - fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[1] > cXforBox1OnPlasticBelt_min AND aBoxX[1] <= cXforBox1OnPlasticBelt_max))
						AND ((aBoxY[2] - aBoxY[3]- fPlasticVelo) >= cBoxWidth OR (aBoxY[2] - aBoxY[3]- fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[2] > cXforBox2OnPlasticBelt_min AND aBoxX[2] <= cXforBox2OnPlasticBelt_max))
						AND ((aBoxY[4] - aBoxY[3]- fPlasticVelo) >= cBoxWidth OR (aBoxY[4] - aBoxY[3]- fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[4] > cXforBox4OnPlasticBelt_min AND aBoxX[4] <= cXforBox4OnPlasticBelt_max));	
						
	aBoxPlasticBelt[4] := aBoxX[4] > cXforBox4OnPlasticBelt_min AND aBoxX[4] <= cXforBox4OnPlasticBelt_max										
						AND ((aBoxY[1] - aBoxY[4] - fPlasticVelo) >= cBoxWidth OR (aBoxY[1] - aBoxY[4] - fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[1] > cXforBox1OnPlasticBelt_min AND aBoxX[1] <= cXforBox1OnPlasticBelt_max))
						AND ((aBoxY[2] - aBoxY[4] - fPlasticVelo) >= cBoxWidth OR (aBoxY[2] - aBoxY[4] - fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[2] > cXforBox2OnPlasticBelt_min AND aBoxX[2] <= cXforBox2OnPlasticBelt_max))
						AND ((aBoxY[3] - aBoxY[4]- fPlasticVelo) >= cBoxWidth OR (aBoxY[3] - aBoxY[4]- fPlasticVelo) <= -cBoxWidth
								OR NOT (aBoxX[3] > cXforBox3OnPlasticBelt_min AND aBoxX[3] <= cXforBox3OnPlasticBelt_max));

// =========================================================
// Motion of boxes on metal belt and back to the start position number 4

	FOR nState := 1 TO 4 BY 1 DO	
		IF bPlasticAxisMoves THEN
				IF 	aBoxPlasticBelt[nState] THEN	
					// Check the state and direction of motion		
					IF bAuto OR bSemi OR (NOT bAuto AND bButtonPlasticFwIn) THEN
						// Move box to the end of metal belt and then back to position 4	
						IF aBoxY[nState] <= (cYBoxesOnMetalPlasticBelt_min + 0.1) AND aBoxY[nState] > cYBoxesOnMetalPlasticBelt_max THEN
							aBoxY[nState] := aBoxY[nState] + fPlasticVelo;
						END_IF
						
					ELSIF NOT bAuto AND bButtonPlasticBwIn THEN
						IF aBoxY[nState] + fPlasticVelo <= (cYBoxesOnMetalPlasticBelt_min - 0.1) THEN
							aBoxY[nState] := aBoxY[nState] + fPlasticVelo;
						END_IF
					END_IF
				END_IF
		END_IF
		
		IF aBoxY[nState] <= cYBoxesOnMetalPlasticBelt_max AND nLastBox = 0 THEN
			aBoxY[nState] := cYforAllBoxesStartPosMainBelt;
			aBoxX[nState] := cXforAllBoxesStartPosMainBelt + nState*cBoxWidth;
		END_IF
	END_FOR

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="AxisRotation" Id="{e54218e4-ab21-4508-af91-eb2b523bd079}">
      <Declaration><![CDATA[METHOD PRIVATE AxisRotation
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Rotation of main axis
	
	fbTimerMainAxis(IN := bMainAxisMoves,
					PT := tMoveAxis);
	
	IF fbTimerMainAxis.Q THEN
		fbTimerMainAxis(IN := FALSE);
		
		IF bAuto OR bSemi THEN
			nAngleMain := nAngleMain + cAxisMovementSemiPlusAuto;
			
		ELSIF bButtonMainFwIn THEN
			nAngleMain := nAngleMain + cAxisMovementManual;
			
		ELSIF bButtonMainBwIn THEN
			nAngleMain := nAngleMain - cAxisMovementManual;
		END_IF
	END_IF

// =========================================================
// Rotation of metal axis
	
	fbTimerMetalAxis( 	IN := bMetalAxisMoves,
						PT := tMoveAxis);
	
	IF fbTimerMetalAxis.Q THEN
		fbTimerMetalAxis( IN := FALSE );
		
		IF bAuto OR bSemi THEN
			nAngleMetal := nAngleMetal + cAxisMovementSemiPlusAuto;
			
		ELSIF bButtonMetalFwIn THEN
			nAngleMetal := nAngleMetal + cAxisMovementManual;
			
		ELSIF bButtonMetalBwIn THEN
			nAngleMetal := nAngleMetal - cAxisMovementManual;
		END_IF
	END_IF

// =========================================================
// Rotation of plastic axis
	
	fbTimerPlasticAxis( IN := bPlasticAxisMoves,
						PT := tMoveAxis);
	
	IF fbTimerPlasticAxis.Q THEN
		fbTimerPlasticAxis( IN := FALSE );
		
		IF bAuto OR bSemi THEN
			nAnglePlastic := nAnglePlastic + cAxisMovementSemiPlusAuto;
			
		ELSIF bButtonPlasticFwIn THEN
			nAnglePlastic := nAnglePlastic + cAxisMovementManual;
			
		ELSIF bButtonPlasticBwIn THEN
			nAnglePlastic := nAnglePlastic - cAxisMovementManual;
		END_IF
	END_IF

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="Barrier_Clamp_Cyl" Id="{ebaebd63-1e2c-4fa1-b813-a22c2850b1ef}">
      <Declaration><![CDATA[METHOD PRIVATE Barrier_Clamp_Cyl
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Moving clamp cylinder
	
	IF bClampToWork THEN
		IF (fYClamp + cClampMovement) < cYClampCylEndPos THEN
			fYClamp := fYClamp + cClampMovement;
		ELSE
			fYClamp := cYClampCylEndPos;
		END_IF
		
	ELSE
		IF (fYClamp - cClampMovement) > cYClampCylStartPos THEN
			fYClamp := fYClamp - cClampMovement;
		ELSE
			fYClamp := cYClampCylStartPos;
		END_IF
	END_IF

// =========================================================
// =========================================================
// Moving barrier cylinder
	
	IF bBarrierToWork THEN
		IF (fYBarrier + cBarrierMovement) < cYBarrierCylEndPos THEN
			fYBarrier := fYBarrier + cBarrierMovement;
		ELSE
			fYBarrier := cYBarrierCylEndPos;
		END_IF
		
	ELSE
		IF (fYBarrier - cBarrierMovement) > cYBarrierCylStartPos THEN
			fYBarrier := fYBarrier - cBarrierMovement;
		ELSE
			fYBarrier := cYBarrierCylStartPos;
		END_IF
	END_IF

// =========================================================
// Checking position of boxes related to the barrier cylinder
	
	IF fYBarrier <= cBoxWidth AND NOT bBarrierToWork THEN
		FOR nState := 1 TO 4 BY 1 DO
			IF aBoxX[nState] > (-cBoxWidth + 0.11 + cBoxWidth*nState) AND aBoxX[nState] < (cBoxWidth*nState + cBarrierWidth) AND aBoxY[nState] = 0
			AND NOT bStopped THEN
				bAccident := TRUE;
			END_IF
		END_FOR
	END_IF

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="ButtonColors" Id="{52bad19d-e118-42cc-905b-dd788c0ab503}">
      <Declaration><![CDATA[METHOD PRIVATE ButtonColors
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Start button
		
	IF (bAccident OR (bPowerEnabled AND (NOT bStarted OR (bSemi AND bStarted))
		AND NOT bButtonStopIn AND NOT bButtonAbortIn AND NOT bButtonResetIn
		AND (bAuto OR bSemi OR bManual OR bMaintenance))) AND NOT (bError AND bIdle) THEN
		
			IF bButtonStartOut THEN
				nButtonColorStart := cGreen;
			ELSE
				nButtonColorStart := cYellow;
			END_IF
			
			bButtonColorStart := TRUE;
	ELSE
		bButtonColorStart := FALSE;
	END_IF

// =========================================================
// Stop button
		
	IF (bStarted OR bIdle) AND (bAuto OR bSemi OR bManual OR bMaintenance) THEN
		IF bButtonStopOut THEN
			nButtonColorStop := cGreen;
		ELSE
			nButtonColorStop := cYellow;
		END_IF
		
		bButtonColorStop := TRUE;
	ELSE
		bButtonColorStop := FALSE;
	END_IF

// =========================================================
// Reset button
		
	IF bStopped AND bPowerEnabled THEN
		IF bButtonResetOut THEN
			nButtonColorReset := cGreen;
		ELSE
			nButtonColorReset := cYellow;		
		END_IF
		
		bButtonColorReset := TRUE;
	ELSE
		bButtonColorReset := FALSE;
	END_IF

// =========================================================
// Mode buttons
	
	IF bPowerEnabled THEN
		IF NOT bAuto THEN
			IF bIdle THEN
				nButtonColorAuto 	:= cYellow;
				bButtonColorAuto 	:= TRUE;
			ELSE
				bButtonColorAuto 	:= FALSE;
			END_IF
		ELSE
			nButtonColorAuto 		:= cGreen;
			bButtonColorAuto 		:= TRUE;
		END_IF
		
		IF NOT bSemi THEN
			IF bIdle THEN
				nButtonColorSemi 	:= cYellow;
				bButtonColorSemi 	:= TRUE;
			ELSE
				bButtonColorSemi 	:= FALSE;
			END_IF
		ELSE
			nButtonColorSemi 		:= cGreen;
			bButtonColorSemi 		:= TRUE;
		END_IF
		
		IF NOT bManual THEN
			IF bIdle THEN
				nButtonColorManu 	:= cYellow;
				bButtonColorManu 	:= TRUE;
			ELSE
				bButtonColorManu 	:= FALSE;
			END_IF
		ELSE
			nButtonColorManu 		:= cGreen;
			bButtonColorManu 		:= TRUE;
		END_IF
		
		IF NOT bMaintenance THEN
			IF bIdle THEN
				nButtonColorMaint 	:= cYellow;
				bButtonColorMaint 	:= TRUE;
			ELSE
				bButtonColorMaint 	:= FALSE;
			END_IF
		ELSE
			nButtonColorMaint 		:= cGreen;
			bButtonColorMaint 		:= TRUE;
		END_IF
	END_IF

// =========================================================
// Buttons to move cylinders and axes
			
	IF (bManual OR bMaintenance) AND bStarted THEN
	// Cylinders
		IF bButtonClampToWorkOut THEN
			nButtonColorClamp 	:= cPink;
		ELSE
			nButtonColorClamp 	:= cYellow;
		END_IF
		
		IF bButtonBarrierToWorkOut THEN
			nButtonColorBarrier := cPink;
		ELSE
			nButtonColorBarrier := cYellow;
		END_IF
		
		IF bButtonMetalToWorkOut THEN
			nButtonColorMetalCyl := cPink;
		ELSE
			nButtonColorMetalCyl := cYellow;
		END_IF
		
		IF bButtonPlasticToWorkOut THEN
			nButtonColorPlasticCyl := cPink;
		ELSE
			nButtonColorPlasticCyl := cYellow;
		END_IF
		
		bButtonColorClamp 		:= TRUE;
		bButtonColorBarrier 	:= TRUE;
		bButtonColorMetalCyl 	:= TRUE;
		bButtonColorPlasticCyl 	:= TRUE;
		
	// Axes
		IF bButtonMainBwOut THEN
			nButtonColorMainBw := cPink;
		ELSE
			nButtonColorMainBw := cYellow;
		END_IF
		
		IF bButtonMainFwOut THEN
			nButtonColorMainFw := cPink;
		ELSE
			nButtonColorMainFw := cYellow;
		END_IF
		
		IF bButtonMetalBwOut THEN
			nButtonColorMetalBw := cPink;
		ELSE
			nButtonColorMetalBw := cYellow;
		END_IF
		
		IF bButtonMetalFwOut THEN
			nButtonColorMetalFw := cPink;
		ELSE
			nButtonColorMetalFw := cYellow;
		END_IF
		
		IF bButtonPlasticBwOut THEN
			nButtonColorPlasticBw := cPink;
		ELSE
			nButtonColorPlasticBw := cYellow;
		END_IF
		
		IF bButtonPlasticFwOut THEN
			nButtonColorPlasticFw := cPink;
		ELSE
			nButtonColorPlasticFw := cYellow;
		END_IF
		
		bButtonColorMainBw 		:= NOT bButtonMainFwOut;
		bButtonColorMainFw 		:= NOT bButtonMainBwOut;
		bButtonColorMetalBw 	:= NOT bButtonMetalFwOut;
		bButtonColorMetalFw 	:= NOT bButtonMetalBwOut;
		bButtonColorPlasticBw 	:= NOT bButtonPlasticFwOut;
		bButtonColorPlasticFw 	:= NOT bButtonPlasticBwOut;
	ELSE
		bButtonColorClamp 		:= FALSE;
		bButtonColorBarrier 	:= FALSE;
		bButtonColorMetalCyl 	:= FALSE;
		bButtonColorPlasticCyl 	:= FALSE;
		bButtonColorMainBw 		:= FALSE;
		bButtonColorMainFw 		:= FALSE;
		bButtonColorMetalBw 	:= FALSE;
		bButtonColorMetalFw 	:= FALSE;
		bButtonColorPlasticBw 	:= FALSE;
		bButtonColorPlasticFw 	:= FALSE;
	END_IF
		
// =========================================================
// Button to control compressed air
			
	IF bMaintenance AND bStarted THEN
		IF bButtonComprAirIn THEN
			nButtonColorComprAir := cGreen;
		ELSE
			nButtonColorComprAir := cYellow;
		END_IF
		
		bButtonColorComprAir := TRUE;
	ELSE
		bButtonColorComprAir := FALSE;
	END_IF

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="ButtonSignals" Id="{21834b0d-f65e-490f-a2af-19593292af59}">
      <Declaration><![CDATA[METHOD PRIVATE ButtonSignals
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// When machine is in requested state, buttons are turned off again

	IF bStartButtonOff THEN
		bButtonStartOut := FALSE;
	END_IF
	
	IF bStopped THEN
		bButtonStopOut := FALSE;
	END_IF
	
	IF bReset THEN
		bButtonResetOut := FALSE;
	END_IF
	
	IF bManual THEN
		bButtonManuOut := FALSE;
	END_IF
	
	IF bAuto THEN
		bButtonAutoOut := FALSE;
	END_IF
	
	IF bSemi THEN
		bButtonSemiOut := FALSE;
	END_IF
	
	IF bMaintenance THEN
		bButtonMaintenanceOut := FALSE;
	END_IF

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="CylinderMoveBoxes" Id="{580d750a-5d59-4322-99d0-c7ea0b543de2}">
      <Declaration><![CDATA[METHOD PRIVATE CylinderMoveBoxes
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Metal cylinder - checking the positions of boxes
// bBoxMetalFree[1] is true, if any box blockades the movement of box 1 on metal belt
	
	aBoxMetalFree[1] := 	NOT (aBoxX[2] > cXforBox2OnMetalBelt_min AND aBoxX[2] <= cXforBox2OnMetalBelt_max AND (aBoxY[1] - aBoxY[2]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[3] > cXforBox3OnMetalBelt_min AND aBoxX[3] <= cXforBox3OnMetalBelt_max AND (aBoxY[1] - aBoxY[3]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[4] > cXforBox4OnMetalBelt_min AND aBoxX[4] <= cXforBox4OnMetalBelt_max AND (aBoxY[1] - aBoxY[4]) <= (cBoxWidth + 1));
	
	aBoxMetalFree[2] := 	NOT (aBoxX[1] > cXforBox1OnMetalBelt_min AND aBoxX[1] <= cXforBox1OnMetalBelt_max AND (aBoxY[2] - aBoxY[1]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[3] > cXforBox3OnMetalBelt_min AND aBoxX[3] <= cXforBox3OnMetalBelt_max AND (aBoxY[2] - aBoxY[3]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[4] > cXforBox4OnMetalBelt_min AND aBoxX[4] <= cXforBox4OnMetalBelt_max AND (aBoxY[2] - aBoxY[4]) <= (cBoxWidth + 1));
						
	aBoxMetalFree[3] := 	NOT (aBoxX[1] > cXforBox1OnMetalBelt_min AND aBoxX[1] <= cXforBox1OnMetalBelt_max AND (aBoxY[3] - aBoxY[1]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[2] > cXforBox2OnMetalBelt_min AND aBoxX[2] <= cXforBox2OnMetalBelt_max AND (aBoxY[3] - aBoxY[2]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[4] > cXforBox4OnMetalBelt_min AND aBoxX[4] <= cXforBox4OnMetalBelt_max AND (aBoxY[3] - aBoxY[4]) <= (cBoxWidth + 1));
						
	aBoxMetalFree[4] := 	NOT (aBoxX[1] > cXforBox1OnMetalBelt_min AND aBoxX[1] <= cXforBox1OnMetalBelt_max AND (aBoxY[4] - aBoxY[1]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[2] > cXforBox2OnMetalBelt_min AND aBoxX[2] <= cXforBox2OnMetalBelt_max AND (aBoxY[4] - aBoxY[2]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[3] > cXforBox3OnMetalBelt_min AND aBoxX[3] <= cXforBox3OnMetalBelt_max AND (aBoxY[4] - aBoxY[3]) <= (cBoxWidth + 1));

// =========================================================
// Metal cylinder - boxes motion
	
	FOR nState := 1 TO 4 BY 1 DO
		IF bMetalToWork AND aBoxMetalMove[nState] AND aBoxMetalFree[nState] THEN
			IF (fYMetal - cMetalPlasticCylMovement) >= (cYMetalPlasticCylEndPos + cMetalPlasticCylMovement) THEN
				fYMetal := fYMetal - cMetalPlasticCylMovement;
				
				IF (fYMetal - aBoxY[nState]) <= cYMetalPlasticCylOnMainBelt THEN
					aBoxY[nState] := aBoxY[nState] - cMetalPlasticCylMovement;
				END_IF
				
			ELSIF fYMetal = (cYMetalPlasticCylEndPos + cMetalPlasticCylMovement) AND (fYMetal - aBoxY[nState]) <= cYMetalPlasticCylOnMainBelt THEN
				aBoxY[nState] := aBoxY[nState] - 2*cMetalPlasticCylMovement;
				
			ELSE
				aBoxMetalMove[nState] := FALSE;
			END_IF
		END_IF	
	END_FOR

// =========================================================
// =========================================================
// Plastic cylinder - checking the positions of boxes

	aBoxPlasticFree[1] := 	NOT (aBoxX[2] > (cXforBox2OnPlasticBelt_min + 20) AND aBoxX[2] <= cXforBox2OnPlasticBelt_max AND (aBoxY[1] - aBoxY[2]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[3] > (cXforBox3OnPlasticBelt_min + 20) AND aBoxX[3] <= cXforBox3OnPlasticBelt_max AND (aBoxY[1] - aBoxY[3]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[4] > (cXforBox4OnPlasticBelt_min + 20) AND aBoxX[4] <= cXforBox4OnPlasticBelt_max AND (aBoxY[1] - aBoxY[4]) <= (cBoxWidth + 1));
	
	aBoxPlasticFree[2] := 	NOT (aBoxX[1] > (cXforBox1OnPlasticBelt_min + 20) AND aBoxX[1] <= cXforBox1OnPlasticBelt_max AND (aBoxY[2] - aBoxY[1]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[3] > (cXforBox3OnPlasticBelt_min + 20) AND aBoxX[3] <= cXforBox3OnPlasticBelt_max AND (aBoxY[2] - aBoxY[3]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[4] > (cXforBox4OnPlasticBelt_min + 20) AND aBoxX[4] <= cXforBox4OnPlasticBelt_max AND (aBoxY[2] - aBoxY[4]) <= (cBoxWidth + 1));
						
	aBoxPlasticFree[3] := 	NOT (aBoxX[1] > (cXforBox1OnPlasticBelt_min + 20) AND aBoxX[1] <= cXforBox1OnPlasticBelt_max AND (aBoxY[3] - aBoxY[1]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[2] > (cXforBox2OnPlasticBelt_min + 20) AND aBoxX[2] <= cXforBox2OnPlasticBelt_max AND (aBoxY[3] - aBoxY[2]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[4] > (cXforBox4OnPlasticBelt_min + 20) AND aBoxX[4] <= cXforBox4OnPlasticBelt_max AND (aBoxY[3] - aBoxY[4]) <= (cBoxWidth + 1));
						
	aBoxPlasticFree[4] := 	NOT (aBoxX[1] > (cXforBox1OnPlasticBelt_min + 20) AND aBoxX[1] <= cXforBox1OnPlasticBelt_max AND (aBoxY[4] - aBoxY[1]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[2] > (cXforBox2OnPlasticBelt_min + 20) AND aBoxX[2] <= cXforBox2OnPlasticBelt_max AND (aBoxY[4] - aBoxY[2]) <= (cBoxWidth + 1))
						AND NOT (aBoxX[3] > (cXforBox3OnPlasticBelt_min + 20) AND aBoxX[3] <= cXforBox3OnPlasticBelt_max AND (aBoxY[4] - aBoxY[3]) <= (cBoxWidth + 1));
					
// =========================================================
// Plastic cylinder - boxes motion

	FOR nState := 1 TO 4 BY 1 DO
		IF bPlasticToWork AND aBoxPlasticMove[nState] AND aBoxPlasticFree[nState] THEN
			IF (fYPlastic - cMetalPlasticCylMovement) >= (cYMetalPlasticCylEndPos + cMetalPlasticCylMovement) THEN
				fYPlastic := fYPlastic - cMetalPlasticCylMovement;
				
				IF (fYPlastic - aBoxY[nState]) <= cYMetalPlasticCylOnMainBelt THEN
					aBoxY[nState] := aBoxY[nState] - cMetalPlasticCylMovement;
				END_IF
				
			ELSIF fYPlastic = (cYMetalPlasticCylEndPos + cMetalPlasticCylMovement) AND (fYPlastic - aBoxY[nState]) <= cYMetalPlasticCylOnMainBelt THEN
				aBoxY[nState] := aBoxY[nState] - 2*cMetalPlasticCylMovement;
				
			ELSE
				aBoxPlasticMove[nState] := FALSE;
			END_IF
		END_IF	
	END_FOR

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="ErrorMessages" Id="{840944dd-5141-4777-960c-32cc4f1bde02}">
      <Declaration><![CDATA[METHOD PRIVATE ErrorMessages
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Error messages
	
	nMessages := 0;
		
	// Main axis
	IF nMainAxisErrorId = 0 THEN
		sMessageMainAxis 	:= '';
	ELSE
		nMessages 			:= nMessages + 1;
		sMessageMainAxis 	:= CONCAT('Error ID of main axis: ', UDINT_TO_STRING(nMainAxisErrorId));
	END_IF
	
	// Metal axis
	IF nMetalAxisErrorId = 0 THEN
		sMessageMetalAxis 	:= '';
	ELSE
		nMessages 			:= nMessages + 1;
		sMessageMetalAxis 	:= CONCAT('Error ID of metal axis: ', UDINT_TO_STRING(nMetalAxisErrorId));
	END_IF
	
	// Plastic axis
	IF nPlasticAxisErrorId = 0 THEN
		sMessagePlasticAxis	:= '';
	ELSE
		nMessages 			:= nMessages + 1;
		sMessagePlasticAxis	:= CONCAT('Error ID of plastic axis: ', UDINT_TO_STRING(nPlasticAxisErrorId));
	END_IF
	
	// Clamp cylinder
	IF bClampError THEN
		nMessages 			:= nMessages + 1;
		sMessageClamp 		:= CONCAT('Error of clamp cylinder: ', sClampErrMsg);
	ELSE
		sMessageClamp 		:= '';
	END_IF
	
	// Metal cylinder
	IF bMetalCylError THEN
		nMessages 			:= nMessages + 1;
		sMessageMetalCyl 	:= CONCAT('Error of metal cylinder: ', sMetalErrMsg);
	ELSE
		sMessageMetalCyl 	:= '';
	END_IF
	
	// Plastic cylinder
	IF bPlasticCylError THEN
		nMessages 			:= nMessages + 1;
		sMessagePlasticCyl 	:= CONCAT('Error of plastic cylinder: ', sPlasticErrMsg);
	ELSE
		sMessagePlasticCyl 	:= '';
	END_IF
	
// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="LastBox" Id="{7237fc0b-1803-4efe-bf33-65240579eca4}">
      <Declaration><![CDATA[METHOD PRIVATE LastBox
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Checking the last position on main belt
	
	IF 		(aBoxX[1] >= (cXforAllBoxesStartPosMainBelt + 1*cBoxWidth - 0.05))
	AND		(aBoxX[1] < (cXforAllBoxesStartPosMainBelt + 2*cBoxWidth - 0.05)) AND (aBoxY[1] = 0) THEN
		nLastBox := 1;
		
	ELSIF 	(aBoxX[2] >= (cXforAllBoxesStartPosMainBelt + 2*cBoxWidth - 0.05))
	AND 	(aBoxX[2] < (cXforAllBoxesStartPosMainBelt + 3*cBoxWidth - 0.05)) AND (aBoxY[2] = 0) THEN
		nLastBox := 2;	
		
	ELSIF 	(aBoxX[3] >= (cXforAllBoxesStartPosMainBelt + 3*cBoxWidth - 0.05))
	AND 	(aBoxX[3] < (cXforAllBoxesStartPosMainBelt + 4*cBoxWidth - 0.05)) AND (aBoxY[3] = 0) THEN
		nLastBox := 3;	
		
	ELSIF 	(aBoxX[4] >= cXforAllBoxesStartPosMainBelt + 4*cBoxWidth - 0.05)
	AND 	(aBoxX[4] < (cXforAllBoxesStartPosMainBelt + 5*cBoxWidth - 0.05)) AND (aBoxY[4] = 0) THEN
		nLastBox := 4;	
		
	ELSE
		nLastBox := 0;
	END_IF		

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="Metal_Plastic_Cyl" Id="{9ce6ad3b-b90d-48de-99c1-c634defea50d}">
      <Declaration><![CDATA[METHOD PRIVATE Metal_Plastic_Cyl
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Moving metal cylinder
	
	IF bMetalToWork THEN
		IF NOT (aBoxMetalMove[1] OR aBoxMetalMove[2] OR aBoxMetalMove[3] OR aBoxMetalMove[4]) THEN
			IF ((fYMetal - cMetalPlasticCylMovement) >= cYMetalPlasticCylEndPos) THEN
				fYMetal := fYMetal - cMetalPlasticCylMovement;
			END_IF
			
		ELSE
			FOR nState := 1 TO 4 BY 1 DO
				IF aBoxMetalMove[nState] THEN
					IF ((fYMetal - cMetalPlasticCylMovement) >= (aBoxY[nState] - cYMetalPlasticCylOnMainBelt - 0.1))
					AND ((fYMetal - cMetalPlasticCylMovement) >= cYMetalPlasticCylEndPos) THEN
						fYMetal := fYMetal - cMetalPlasticCylMovement;
					END_IF
				END_IF
			END_FOR
		END_IF
		
	ELSE
		IF ((fYMetal + cMetalPlasticCylMovement) < cYMetalPlasticCylStartPos) THEN
			fYMetal := fYMetal + cMetalPlasticCylMovement;
		ELSE
			fYMetal := cYMetalPlasticCylStartPos;
		END_IF
	END_IF

// =========================================================
// Checking position of boxes related to the metal cylinder
	
	IF (fYMetal < (cYMetalPlasticCylOnMainBelt + 0.1)) AND (fYMetal > (cYMetalPlasticCylOnMainBelt - 0.1)) AND bMetalToWork THEN
		FOR nState := 1 TO 4 BY 1 DO
			// box on main belt
			IF (aBoxY[nState] >= cYforAllBoxesOnMainBelt) THEN
				// box in right position related to the metal cylinder
				IF (aBoxX[nState] > (cXforAllBoxesCorrectPushMetalCyl_min + cBoxWidth*nState))
				AND (aBoxX[nState] <= (cXforAllBoxesCorrectPushMetalCyl_max + cBoxWidth*nState)) THEN
					aBoxMetalMove[nState] := TRUE;
				END_IF
				
				// box in wrong position related to the metal cylinder >> accident
				IF ((aBoxX[nState] > (cXforAllBoxesIncorrectPushMetalCyl_min + cBoxWidth*nState)
						AND aBoxX[nState] <= (cXforAllBoxesCorrectPushMetalCyl_min + cBoxWidth*nState))
					OR (aBoxX[nState] > (cXforAllBoxesCorrectPushMetalCyl_max + cBoxWidth*nState)
						AND aBoxX[nState] < (cXforAllBoxesIncorrectPushMetalCyl_max + cBoxWidth*nState)))
				AND NOT bStopped THEN
					bAccident := TRUE;
				END_IF
			END_IF
		END_FOR
	END_IF

// =========================================================
// =========================================================
// Moving plastic cylinder
	
	IF bPlasticToWork THEN
		IF NOT (aBoxPlasticMove[1] OR aBoxPlasticMove[2] OR aBoxPlasticMove[3] OR aBoxPlasticMove[4]) THEN
			IF ((fYPlastic - cMetalPlasticCylMovement) >= cYMetalPlasticCylEndPos) THEN
				fYPlastic := fYPlastic - cMetalPlasticCylMovement;
			END_IF
			
		ELSE
			FOR nState := 1 TO 4 BY 1 DO
				IF aBoxPlasticMove[nState] THEN
					IF ((fYPlastic - cMetalPlasticCylMovement) >= (aBoxY[nState] - cYMetalPlasticCylOnMainBelt - 0.1))
					AND ((fYPlastic - cMetalPlasticCylMovement) >= cYMetalPlasticCylEndPos) THEN
						fYPlastic := fYPlastic - cMetalPlasticCylMovement;
					END_IF
				END_IF
			END_FOR
		END_IF
		
	ELSE
		IF ((fYPlastic + cMetalPlasticCylMovement) < cYMetalPlasticCylStartPos) THEN
			fYPlastic := fYPlastic + cMetalPlasticCylMovement;
		ELSE
			fYPlastic := cYMetalPlasticCylStartPos;
		END_IF
	END_IF

// =========================================================
// Checking position of boxes related to the plastic cylinder
		
	IF ((aBoxX[1] > (cXforAllBoxesLastPossiblePosMainBelt + 1*cBoxWidth))
		OR (aBoxX[2] > (cXforAllBoxesLastPossiblePosMainBelt + 2*cBoxWidth))
		OR (aBoxX[3] > (cXforAllBoxesLastPossiblePosMainBelt + 3*cBoxWidth))
		OR (aBoxX[4] > (cXforAllBoxesLastPossiblePosMainBelt + 4*cBoxWidth)))
	AND NOT bStopped THEN
		bAccident := TRUE;
	END_IF
		
	IF (fYPlastic < (cYMetalPlasticCylOnMainBelt + 0.1)) AND (fYPlastic > (cYMetalPlasticCylOnMainBelt - 0.1)) AND bPlasticToWork THEN
		FOR nState := 1 TO 4 BY 1 DO
			// box on main belt
			IF aBoxY[nState] >= cYforAllBoxesOnMainBelt THEN
				// box in right position related to the plastic cylinder
				IF (aBoxX[nState] > (cXforAllBoxesCorrectPushPlasticCyl_min + cBoxWidth*nState))
				AND (aBoxX[nState] <= (cXforAllBoxesCorrectPushPlasticCyl_max + cBoxWidth*nState)) THEN
					aBoxPlasticMove[nState] := TRUE;
				END_IF
				
				// box in wrong position related to the plastic cylinder >> accident
				IF (aBoxX[nState] > (cXforAllBoxesIncorrectPushPlasticCyl_min + cBoxWidth*nState))
				AND (aBoxX[nState] <= (cXforAllBoxesCorrectPushPlasticCyl_min + cBoxWidth*nState))
				AND NOT bStopped THEN
					bAccident := TRUE;
				END_IF	
			END_IF
		END_FOR
	END_IF

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{cc06cfcd-bcea-40ca-b8c1-bd9d4b28425d}">
      <Declaration><![CDATA[METHOD PRIVATE Reset
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// =========================================================
// Resetting visu
	
	// Cylinder buttons
	bButtonClampToWorkOut 		:= FALSE;
	bButtonBarrierToWorkOut 	:= FALSE;
	bButtonMetalToWorkOut 		:= FALSE;
	bButtonPlasticToWorkOut 	:= FALSE;
	
	// Axis buttons
	bButtonMainBwOut 			:= FALSE;
	bButtonMainFwOut 			:= FALSE;
	bButtonMetalBwOut 			:= FALSE;
	bButtonMetalFwOut 			:= FALSE;
	bButtonPlasticBwOut			:= FALSE;
	bButtonPlasticFwOut			:= FALSE;
	
	// State and mode buttons
	bButtonStartOut 			:= FALSE;
	bButtonStopOut 				:= FALSE;
	bButtonResetOut 			:= FALSE;
	bButtonComprAirOut 			:= FALSE;
	bButtonManuOut 				:= FALSE;
	bButtonAutoOut 				:= FALSE;
	bButtonSemiOut 				:= FALSE;
	bButtonMaintenanceOut		:= FALSE;
	
	// Position of boxes and cylinders	
	FOR nState := 1 TO 4 BY 1 DO
		aBoxX[nState] 			:= 0;
		aBoxY[nState] 			:= 0;
		
		aBoxMetalMove[nState] 	:= FALSE;
		aBoxPlasticMove[nState]	:= FALSE;
		aBoxMainBelt[nState]	:= FALSE;
		aBoxMetalBelt[nState] 	:= FALSE;
		aBoxPlasticBelt[nState]	:= FALSE;
	END_FOR
	
	bAccident := FALSE;

// =========================================================]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Visu">
      <LineId Id="3" Count="60" />
      <LineId Id="2" Count="0" />
      <LineId Id="374" Count="0" />
      <LineId Id="363" Count="0" />
      <LineId Id="375" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="364" Count="1" />
      <LineId Id="370" Count="0" />
      <LineId Id="366" Count="0" />
      <LineId Id="372" Count="1" />
      <LineId Id="382" Count="0" />
      <LineId Id="381" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.AxisMoveBoxes">
      <LineId Id="3" Count="314" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.AxisRotation">
      <LineId Id="3" Count="59" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.Barrier_Clamp_Cyl">
      <LineId Id="3" Count="48" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.ButtonColors">
      <LineId Id="3" Count="205" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.ButtonSignals">
      <LineId Id="3" Count="30" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.CylinderMoveBoxes">
      <LineId Id="3" Count="81" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.ErrorMessages">
      <LineId Id="3" Count="52" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.LastBox">
      <LineId Id="3" Count="22" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.Metal_Plastic_Cyl">
      <LineId Id="3" Count="112" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Visu.Reset">
      <LineId Id="3" Count="40" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>